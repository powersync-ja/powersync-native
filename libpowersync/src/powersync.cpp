#include "powersync.h"

namespace powersync::internal {
    // Not generated by cbindgen
    struct InnerPowerSyncState;
}

#include "bindings.h"
#include "helpers.h"

namespace powersync {
    static void handle_result(internal::PowerSyncResultCode rc) {
        if (rc != internal::PowerSyncResultCode::OK) {
            auto msg = internal::powersync_last_error_desc();
            throw Exception(1, msg);
        }
    }

    void internal::RawCompletionHandle::send_credentials(const char* endpoint, const char* token) {
        powersync_completion_handle_complete_credentials(&this->rust_handle, endpoint, token);
    }

    void internal::RawCompletionHandle::send_empty() {
        powersync_completion_handle_complete_empty(&this->rust_handle);
    }

    void internal::RawCompletionHandle::send_error_code(int code) {
        powersync_completion_handle_complete_error_code(&this->rust_handle, code);
    }

    void internal::RawCompletionHandle::send_error_message(int code, const char* message) {
        powersync_completion_handle_complete_error_msg(&this->rust_handle, code, message);
    }

    internal::RawCompletionHandle::~RawCompletionHandle() {
        powersync_completion_handle_free(&this->rust_handle);
    }


    const char * Exception::what() const noexcept {
        if (this->msg) {
            return this->msg;
        }

        return "Unknown error";
    }

    void RustTableHelper::map_column(std::vector<internal::Column>& target, const Column &column) {
        internal::ColumnType type = {};
        switch (column.type) {
            case TEXT:
                type = internal::ColumnType::Text;
                break;
            case INTEGER:
                type = internal::ColumnType::Integer;
                break;
            case REAL:
                type = internal::ColumnType::Real;
                break;
        }

        target.emplace_back() = {
            .name = column.name.c_str(),
            .column_type = type,
        };
    }

    void RustTableHelper::map_table(const Table &table) {
        std::vector<internal::Column> columns = {};
        for (const auto& column : table.columns) {
            map_column(columns, column);
        }

        auto& managedColumns= this->columns.emplace_back(std::move(columns));
        const char* view_name_override = nullptr;
        if (table.view_name_override.has_value()) {
            view_name_override = table.view_name_override.value().c_str();
        }

        this->tables.emplace_back() = {
            .name = table.name.c_str(),
            .view_name_override = view_name_override,
            .columns = &managedColumns.front(),
            .column_len = managedColumns.size(),
            .local_only = table.local_only,
            .insert_only = table.insert_only,
            .track_metadata = table.track_metadata,
            .ignore_empty_updates = table.ignore_empty_updates,
        };
    }

    internal::RawSchema RustTableHelper::to_rust() {
        return {
            .tables = &this->tables.front(),
            .tables_len = this->tables.size(),
        };
    }

    static RustTableHelper schema_helper(const Schema& schema) {
        RustTableHelper result;
        for (const auto& table : schema.tables) {
            result.map_table(table);
        }

        return result;
    }

    Exception::~Exception() noexcept {
        if (this->msg) {
            internal::powersync_free_str(this->msg);
        }
    }

    Database Database::in_memory(const Schema& schema) {
        auto helper = schema_helper(schema);

        internal::RawPowerSyncDatabase db{};
        handle_result(internal::powersync_db_in_memory(helper.to_rust(), &db));

        return Database(db);
    }

    void Database::connect(std::shared_ptr<BackendConnector> connector) {
        struct RawConnector: internal::CppConnector {
            std::shared_ptr<BackendConnector> connector;

            RawConnector(std::shared_ptr<BackendConnector> connector) : CppConnector(), connector(std::move(connector)) {
                this->upload_data = &upload_data_impl;
                this->fetch_credentials = &fetch_credentials_impl;
                this->drop = &drop_impl;
            }

            static void upload_data_impl(CppConnector* connector, internal::CppCompletionHandle handle) {
                auto raw = static_cast<RawConnector*>(connector);
                CompletionHandle<std::monostate> wrapped(internal::RawCompletionHandle {
                    .rust_handle = handle
                });

                raw->connector->upload_data(wrapped);
            }

            static void fetch_credentials_impl(CppConnector* connector, internal::CppCompletionHandle handle) {
                auto raw = static_cast<RawConnector*>(connector);
                CompletionHandle<PowerSyncCredentials> wrapped(internal::RawCompletionHandle {
                                    .rust_handle = handle
                                });

                raw->connector->fetch_token(wrapped);
            }

            static void drop_impl(CppConnector* connector) {
                auto raw = static_cast<RawConnector*>(connector);
                delete raw;
            }
        };

        const auto raw_connector = new RawConnector(connector);
        const auto rc = internal::powersync_db_connect(&raw, raw_connector);
        handle_result(rc);
    }

    void Database::spawn_sync_thread() {
        auto raw = &this->raw;
        std::thread thread([raw]() {
            // TODO: There is a race condition here when the database's destructor runs before we reach this call.
            internal::powersync_run_tasks(raw);
        });

        this->worker = std::move(thread);
    }

    LeasedConnection Database::reader() const {
        internal::ConnectionLeaseResult result{};

        handle_result(internal::powersync_db_reader(&this->raw, &result));
        return {result.sqlite3, result.lease};
    }

    LeasedConnection Database::writer() const {
        internal::ConnectionLeaseResult result{};

        handle_result(internal::powersync_db_writer(&this->raw, &result));
        return {result.sqlite3, result.lease};
    }

    Database::~Database() {
        if (this->raw.inner) {
            // First, clear the database client (unless resources have been moved out of this class).
            internal::powersync_db_free(this->raw);
        }

        // Dropping the client will asynchronously complete sync actors, so join that.
        if (this->worker.has_value()) {
            this->worker->join();
        }
    }

    LeasedConnection::~LeasedConnection() {
        internal::powersync_db_return_lease(static_cast<internal::RawConnectionLease*>(this->raw_lease));
    }

    LeasedConnection::operator sqlite3 *() const {
        return this->db;
    }
}
