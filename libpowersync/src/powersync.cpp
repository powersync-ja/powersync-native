#include "powersync.h"

namespace powersync::internal {
    // Not generated by cbindgen
    struct InnerPowerSyncState;
}

#include "bindings.h"
#include "helpers.h"

namespace powersync {
    void set_logger(LogLevel level, void(*logger)(LogLevel, const char*)) {
        auto wrapper = internal::CppLogger {
            .level = static_cast<internal::LogLevel>(level),
            .native_log = reinterpret_cast<void(*)(internal::LogLevel, const char *)>(logger),
        };

        if (auto rc = internal::powersync_install_logger(wrapper)) {
            throw Exception(rc, "Could not set logger");
        }
    }

    static void handle_result(internal::PowerSyncResultCode rc) {
        if (rc != internal::PowerSyncResultCode::OK) {
            auto msg = internal::powersync_last_error_desc();
            throw Exception(1, msg);
        }
    }

    static std::string resolve_string(internal::StringView& source) {
        size_t count = source.length;
        return {source.value, count};
    }

    static std::optional<std::string> resolve_string(internal::StringView& source, bool exists) {
        if (!exists) {
            return std::nullopt;
        }

        return resolve_string(source);
    }

    void internal::RawCompletionHandle::send_credentials(const char* endpoint, const char* token) {
        powersync_completion_handle_complete_credentials(&this->rust_handle, endpoint, token);
    }

    void internal::RawCompletionHandle::send_empty() {
        powersync_completion_handle_complete_empty(&this->rust_handle);
    }

    void internal::RawCompletionHandle::send_error_code(int code) {
        powersync_completion_handle_complete_error_code(&this->rust_handle, code);
    }

    void internal::RawCompletionHandle::send_error_message(int code, const char* message) {
        powersync_completion_handle_complete_error_msg(&this->rust_handle, code, message);
    }

    internal::RawCompletionHandle::~RawCompletionHandle() {
        powersync_completion_handle_free(&this->rust_handle);
    }


    const char * Exception::what() const noexcept {
        if (this->msg) {
            return this->msg;
        }

        return "Unknown error";
    }

    void RustTableHelper::map_column(std::vector<internal::Column>& target, const Column &column) {
        internal::ColumnType type = {};
        switch (column.type) {
            case TEXT:
                type = internal::ColumnType::Text;
                break;
            case INTEGER:
                type = internal::ColumnType::Integer;
                break;
            case REAL:
                type = internal::ColumnType::Real;
                break;
        }

        target.emplace_back() = {
            .name = column.name.c_str(),
            .column_type = type,
        };
    }

    void RustTableHelper::map_table(const Table &table) {
        std::vector<internal::Column> columns = {};
        for (const auto& column : table.columns) {
            map_column(columns, column);
        }

        auto& managedColumns= this->columns.emplace_back(std::move(columns));
        const char* view_name_override = nullptr;
        if (table.view_name_override.has_value()) {
            view_name_override = table.view_name_override.value().c_str();
        }

        this->tables.emplace_back() = {
            .name = table.name.c_str(),
            .view_name_override = view_name_override,
            .columns = &managedColumns.front(),
            .column_len = managedColumns.size(),
            .local_only = table.local_only,
            .insert_only = table.insert_only,
            .track_metadata = table.track_metadata,
            .ignore_empty_updates = table.ignore_empty_updates,
        };
    }

    internal::RawSchema RustTableHelper::to_rust() {
        return {
            .tables = &this->tables.front(),
            .tables_len = this->tables.size(),
        };
    }

    static RustTableHelper schema_helper(const Schema& schema) {
        RustTableHelper result;
        for (const auto& table : schema.tables) {
            result.map_table(table);
        }

        return result;
    }

    Exception::~Exception() noexcept {
        if (this->msg) {
            internal::powersync_free_str(this->msg);
        }
    }

    Database Database::in_memory(const Schema& schema) {
        auto helper = schema_helper(schema);

        internal::RawPowerSyncDatabase db{};
        handle_result(internal::powersync_db_in_memory(helper.to_rust(), &db));

        return Database(db);
    }

    void Database::connect(std::shared_ptr<BackendConnector> connector) {
        struct RawConnector: internal::CppConnector {
            std::shared_ptr<BackendConnector> connector;

            RawConnector(std::shared_ptr<BackendConnector> connector) : CppConnector(), connector(std::move(connector)) {
                this->upload_data = &upload_data_impl;
                this->fetch_credentials = &fetch_credentials_impl;
                this->drop = &drop_impl;
            }

            static void upload_data_impl(CppConnector* connector, internal::CppCompletionHandle handle) {
                auto raw = static_cast<RawConnector*>(connector);
                CompletionHandle<std::monostate> wrapped(internal::RawCompletionHandle {
                    .rust_handle = handle
                });

                raw->connector->upload_data(wrapped);
            }

            static void fetch_credentials_impl(CppConnector* connector, internal::CppCompletionHandle handle) {
                auto raw = static_cast<RawConnector*>(connector);
                CompletionHandle<PowerSyncCredentials> wrapped(internal::RawCompletionHandle {
                                    .rust_handle = handle
                                });

                raw->connector->fetch_token(wrapped);
            }

            static void drop_impl(CppConnector* connector) {
                auto raw = static_cast<RawConnector*>(connector);
                delete raw;
            }
        };

        const auto raw_connector = new RawConnector(connector);
        const auto rc = internal::powersync_db_connect(&raw, raw_connector);
        handle_result(rc);
    }

    void Database::spawn_sync_thread() {
        auto raw = &this->raw;
        std::thread thread([raw]() {
            // TODO: There is a race condition here when the database's destructor runs before we reach this call.
            internal::powersync_run_tasks(raw);
        });

        this->worker = std::move(thread);
    }

    LeasedConnection Database::reader() const {
        internal::ConnectionLeaseResult result{};

        handle_result(internal::powersync_db_reader(&this->raw, &result));
        return {result.sqlite3, result.lease};
    }

    LeasedConnection Database::writer() const {
        internal::ConnectionLeaseResult result{};

        handle_result(internal::powersync_db_writer(&this->raw, &result));
        return {result.sqlite3, result.lease};
    }

    Database::~Database() {
        if (this->raw.inner) {
            // First, clear the database client (unless resources have been moved out of this class).
            internal::powersync_db_free(this->raw);
        }

        // Dropping the client will asynchronously complete sync actors, so join that.
        if (this->worker.has_value()) {
            this->worker->join();
        }
    }

    LeasedConnection::~LeasedConnection() {
        internal::powersync_db_return_lease(static_cast<internal::RawConnectionLease*>(this->raw_lease));
    }

    LeasedConnection::operator sqlite3 *() const {
        return this->db;
    }

    CrudTransactions Database::get_crud_transactions() const {
        auto iterator = internal::powersync_crud_transactions_new(&this->raw);
        return {*this, iterator};
    }

    bool CrudTransactions::advance() {
        bool has_next = false;
        handle_result(internal::powersync_crud_transactions_step(this->rust_iterator, &has_next));
        return has_next;
    }

    CrudTransaction CrudTransactions::current() const {
        auto tx = internal::powersync_crud_transactions_current(this->rust_iterator);
        std::vector<CrudEntry> crud;

        for (intptr_t i = 0; i < tx.crud_length; i++) {
            auto entry = internal::powersync_crud_transactions_current_crud_item(this->rust_iterator, i);

            crud.push_back({
                .client_id = entry.client_id,
                .transaction_id = entry.transaction_id,
                .update_type = static_cast<UpdateType>(entry.update_type),
                .table = resolve_string(entry.table),
                .id = resolve_string(entry.id),
                .metadata = resolve_string(entry.metadata, entry.has_metadata),
                .data = resolve_string(entry.data, entry.has_data),
                .previous_values = resolve_string(entry.previous_values, entry.has_previous_values),
            });
        }

        return CrudTransaction {
            .db = this->db,
            .last_item_id = tx.last_item_id,
            .id = tx.has_id ? std::make_optional(tx.id) : std::nullopt,
            .crud = crud,
        };
    }

    CrudTransactions::~CrudTransactions() {
        if (this->rust_iterator) {
            internal::powersync_crud_transactions_free(this->rust_iterator);
        }
    }

    void CrudTransaction::complete() const {
        this->complete(std::nullopt);
    }

    void CrudTransaction::complete(std::optional<int64_t> custom_write_checkpoint) const {
        internal::powersync_crud_complete(&db.raw, this->last_item_id,
        custom_write_checkpoint.has_value(),
        custom_write_checkpoint.has_value() ? custom_write_checkpoint.value(): 0);
    }
}
